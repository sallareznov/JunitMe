\section{Algorithm}
\label{sec:Algorithm}
\subsection{Java to Alloy}
\subsubsection{Generating Alloy source code}
\paragraph{Base model}
The base model is a meta-model, It is the base of the generated java to Alloy program.
It is composed of four parts: Types, methods, methods constraints and arguments of these methods.
\subparagraph{Types}
***********************
\lstset{language=Alloy}
\begin{lstlisting}
abstract sig Type{
}

sig Object{
   type : Type
}
\end{lstlisting}

\subparagraph{Methods}
***********************
\lstset{language=Alloy}
\begin{lstlisting}
abstract sig CallWithNext extends Call{
   nextMethod : Call
}

sig MethodCall extends CallWithNext{
   receiver : Object,
   method : Method,
   params : seq Object
}

one sig Begin extends CallWithNext{
}

abstract sig Method {
   paramTypes : seq Type,
   receiverType : Type
}
\end{lstlisting}

\subparagraph{Constraints}
***********************
\lstset{language=Alloy}
\begin{lstlisting}
------ Method Constraints-------


-- There must be one and only one method.next= end
fact{
   one m : MethodCall | m.nextMethod in End
}

-- Method call cant link to itself
fact{
   all mc : MethodCall | mc.nextMethod!=mc
}

-- The receiver has the right type
fact{
   all mc : MethodCall |  mc.receiver.type=mc.method.receiverType
}

-- A call can't be done twice
fact{
all mc: MethodCall | no mc2 : MethodCall |  (mc2 in mc.^nextMethod) && (mc2.nextMethod=mc)
}

-- All methodCall Has been called
fact{
   all mc : MethodCall | one c : CallWithNext | c.nextMethod=mc
}

-- Object calling a method has the right type
fact{
   all mc:MethodCall | mc.receiver.type=mc.method.receiverType
}

\end{lstlisting}
\subparagraph{Methods arguments}
***********************
\lstset{language=Alloy}
\begin{lstlisting}
------- Param Constraints ------

-- Types verification (method declaration/method calling)
fact{
   all mc : MethodCall |validParam[mc.method,mc]
}

pred validParam[method : Method, call : MethodCall]{
	call.params.type=method.paramTypes
	#call.params=#method.paramTypes
    all  pt : method.paramTypes.elems | all p : call.params.elems | call.params.idxOf[p]=method.paramTypes.idxOf[pt] implies pt=p.type
}

-------- Primitive Types ------------

one sig Gen_Double extends Type{}
one sig Gen_Integer extends Type{}
one sig Gen_Float extends Type{}
one sig Gen_Boolean extends Type{}
one sig Gen_Byte extends Type{}
one sig Gen_Character extends Type{}
one sig Gen_Long extends Type{}
one sig Gen_Short extends Type{}
\end{lstlisting}
\paragraph{Code generation}
To generate Alloy instances for an existing Java program we used Spoon. Spoon uses AST (Abstract syntax tree)\cite{ast} to browse the structure of a specified program. With informations collected in the AST, we are able to generate the code of Alloy program corresponding to the initial Java program. The generated code is then grafted to the base model.
Result is a complet Alloy model inside the file FinalGen.als
\lstset{language=Java}
\begin{lstlisting}
//here we should add an Algo
new String();
\end{lstlisting}
\subsection{Alloy to Java}
\subsubsection{Generating Java unit tests}
\paragraph{Modelizing Alloy instances in Java}
Using Alloy Analyzer we execute the generated Alloy source code. Alloy Analyzer generates all possible instances.
Each instance is a solution, we can obtain a solution using A4Solution object. A4Solution object has a method \textit{satisfiable} to check if the solution is valid and a method \textit{next} to go the next possible solution.

\paragraph{Creating Java object}
Each alloy instance is represented by a Java object called: \textit{AlloyInstance}.***************

\paragraph{Generating tests}
In order To generate the code of Java unit tests we used CodeModel, which allows us to generate Java classes in a simple way.\\
We browse Java modelized solution and we generate the variables used to call methods and the variables passed as methods parameters.\\
For each solution we use the execution trace.
Firstly, we initalize all the necessary types for the receiver method, then all the veriables that will be used in parameters.

